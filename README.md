# Coin Change Problem

## Опис
Цей проект реалізує два методи для вирішення задачі видачі решти:
1. `find_coins_greedy`: Використовує жадібний алгоритм для визначення мінімальної кількості монет для досягнення заданої суми.
2. `find_min_coins`: Використовує динамічне програмування для визначення мінімальної кількості монет для досягнення заданої суми.

## Алгоритми

### Жадібний Алгоритм
Жадібний алгоритм завжди вибирає найбільший номінал монети, зменшуючи суму до тих пір, поки вона не стане нульовою.
- **Часова складність:** O(n), де n - кількість монет.
- **Просторова складність:** O(1).

### Динамічне Програмування
Метод динамічного програмування розв’язує всі підзадачі і зберігає їх рішення для подальшого використання.
- **Часова складність:** O(n * m), де n - сума, а m - кількість різних монет.
- **Просторова складність:** O(n).

## Використання
Функції можна використовувати наступним чином:

```python
find_coins_greedy(amount, coins)
find_min_coins(amount, coins)

## Порівняння
Для стандартних номіналів монет жадібний алгоритм зазвичай швидший і використовує менше пам’яті. Однак, метод динамічного програмування гарантує правильне мінімальне число монет для будь-якого набору номіналів.

## Приклади
Жадібний: Для суми 113 з монетами [50, 25, 10, 5, 2, 1], повертає {50: 2, 10: 1, 2: 1, 1: 1}.
Динамічне Програмування: Для суми 113 з монетами [50, 25, 10, 5, 2, 1], повертає {50: 2, 10: 1, 2: 1, 1: 1}.
Продуктивність
Жадібний Алгоритм: Швидкий і ефективний для великих сум зі стандартними номіналами.
Динамічне Програмування: Повільніший, але гарантує оптимальне рішення для будь-яких номіналів монет.
